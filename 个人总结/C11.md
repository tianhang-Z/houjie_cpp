## 语言

#### variadic templates 可变模板参数 `typename... Types`

下图中函数2和3可以共存，函数2其实是函数3的特化

`...`是一个关键字，表示一个pack，`...`可以用于模板参数pack、函数参数类型pack、函数参数pack，如下图代码。 

```c++
void print() {}
template<typename T,typename... Types>
void print(const T& fisrtArg,const Types&... args){
	cout<<firstArg<endl;
	print(args...);
}
```



![image-20250606160819805](./image/C11_image/image-20250606160819805.png)

##### 用处：std::tuple

递归函数调用



![image-20250606162254868](./image/C11_image/image-20250606162254868.png)

下图是tuple的构造过程，右边显示了继承关系。

tuple由父类inherited和m_head构成，在内存中，先构造父类后构造子类，**父类的部分一般位于低地址**（编译器决定），以下图为例，右侧的继承关系可以反映构造函数调用顺序，最终"nico"位于最低的地址，4位于最高的地址处。

当调用tail函数时，返回父类部分的引用。

当我们说 `tuple` 的 **tail（尾部）** 时，通常是指：

- 给定一个 `tuple` 包含多个类型，比如 `tuple<int, double, string>`；
- 它的 **head（头部）** 是第一个类型 `int`；
- 它的 **tail（尾部）** 是剩下的类型 `double, string`。

![image-20250606171638402](./image/C11_image/image-20250606171638402.png)



#### spaces in template expressions

在过去，`vector<list<int> >`最后一定要有空格隔开；c11之后不需要了

![image-20250606174259707](./image/C11_image/image-20250606174259707.png)

#### nullptr 和 std::nullptr_t

nullptr是一个新的关键字，**专门表示空指针的字面量**，其类型是 `std::nullptr_t`。

`nullptr` 可以隐式转换为任何指针类型（比如 `int*`、`void*` 等），但**不会隐式转换为整数类型**，

使用nullptr代替NULL，因为NULL被定义为0，当NULL作为参数传递时可能有二义性，如`void f(void*), void f(int)`，函数由`int`作为参和`void*`作为参的两个版本。

`std::nullptr_t` 是 `nullptr` 的类型，它是在 C++11 中引入的一个**标准库类型**，定义在头文件 `<cstddef>` 中。

![image-20250606174432091](./image/C11_image/image-20250606174432091.png)

#### auto

类型名称比较长的时候经常使用，比如迭代器类型

还用于表示lambda函数返回类型

![image-20250606175539639](./image/C11_image/image-20250606175539639.png)

![image-20250606175625407](./image/C11_image/image-20250606175625407.png)

`auto` 的类型推导规则

|           初始化表达式           | 推导出的类型 |                         说明                         |
| :------------------------------: | :----------: | :--------------------------------------------------: |
|    `int a = 10; auto b = a;`     |    `int`     |               完全保留变量 `a` 的类型                |
| `const int a = 10; auto b = a;`  |    `int`     |               `auto` 会忽略顶层 const                |
| `const int& a = 10; auto b = a;` |    `int`     |            `auto` 会忽略引用和顶层 const             |
|          `auto& b = a;`          | `const int&` |          使用 `auto&` 可以保留引用和 const           |
|         `auto&& b = a;`          | `const int&` | 万能引用，根据初始化表达式决定是左值引用还是右值引用 |

![image-20250606175634795](./image/C11_image/image-20250606175634795.png)

#### decltype

`decltype` 的主要作用是**在编译时获取表达式或变量的类型**，它不会像 `auto` 那样声明变量，而是返回一个类型。常用于模板中进行类型推断，`-> decltype`

|               特性                |                  `auto`                  |                      `decltype`                      |
| :-------------------------------: | :--------------------------------------: | :--------------------------------------------------: |
|           **引入版本**            |                  C++11                   |                        C++11                         |
|             **用途**              | 用于声明变量时从初始化表达式推导变量类型 | 用于在编译时获取表达式或变量的类型（不直接声明变量） |
|     **是否可以用于变量声明**      |                   ✅ 是                   |     ❌ 否（但可以结合 `std::declval` 或模板使用）     |
| **是否可以用于函数返回类型推导**  |          ✅ 是（C++14 起更强大）          |            ✅ 是（通常结合 `-> decltype`）            |
| **是否保留引用和 const 等修饰符** |           ✅ 是（但有特定规则）           |           ✅ 是（完全保留表达式的类型信息）           |
| **是否可以用于推导表达式的类型**  |                   ❌ 否                   |                         ✅ 是                         |

#### uniform initialization

c11之前，初始化可能发生在小括号，大括号，赋值运算符。

c11之后，可以统一使用大括号。

其原理是：**编译器遇到大括号，会处理成一个`initializer_list<T>`，其背后是`array<T,n>`**

注意下面的例子，但ctor可以接受initializer_list<T>作为参数时，即直接传入initializer_list<T>；否则，将其分解后传给ctor的各个参数。

**所有的容器都提供了接受initializer_list<T>的ctor**

![image-20250608220001213](./image/C11_image/image-20250608220001213.png)



#### initializer list

##### 大括号会自动防止窄化 

默认初始化为0；

一旦使用{}初始化，窄化时会warning

![image-20250608221156397](./image/C11_image/image-20250608221156397.png)

![image-20250608221628965](./image/C11_image/image-20250608221628965.png)

##### 背后原理 initializer_list<>

![image-20250608221828044](./image/C11_image/image-20250608221828044.png)

ctor可接受initializer_list时，优先使用这个ctor。 （下图左

下图右，是initializer_list的代码。

编译器层面，编译器遇到{}时，编译器确定数组大小；运行时，遇到{}会先初始化静态数组array，即将元素拷贝到分配的数组空间，这个数组是一个临时对象；之后会调用initializer_list的私有构造函数初始化内部的array迭代器。

initialzer_list只有array的视图，且array和initializer_list都是临时对象，在外围的容器构造完成后，二者都会销毁。

![image-20250608222249280](./image/C11_image/image-20250608222249280.png)



![image-20250608224311037](./image/C11_image/image-20250608224311037.png)

**下图中`_M_elems`为`_Tp[_Num]`数组类型**

![image-20250608225741852](./image/C11_image/image-20250608225741852.png)

initializer_list中存放的是array的指针（迭代器）

`std::initializer_list` 并不实际存储元素，而是提供了一种 **轻量级的 "视图"**，指向一个底层的、由编译器生成的 **静态数组**。

![image-20250608230040778](./image/C11_image/image-20250608230040778.png)

**下图说明所有容器支持使用{}进行初始化，赋值，insert，assign。min,max也支持接受{}中任意个数元素**

![image-20250608231025058](./image/C11_image/image-20250608231025058.png)

![image-20250608231225649](./image/C11_image/image-20250608231225649.png)

## STL